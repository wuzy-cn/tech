<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>性能分析方法论及策略——传统方法与 BPF 方法 - Eternal Sunshine</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Eternal Sunshine"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Eternal Sunshine"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文将从系统维护者的角度对性能优化相关的方法论进行梳理，并特别阐述新生的 eBPF 给性能分析领域带来的影响。由于不同读者的知识领域并不完全相同，所以本文将不会涉及到具体实现，但只要读者有性能优化的需求，那么本文可能就会有所裨益。"><meta property="og:type" content="blog"><meta property="og:title" content="性能分析方法论及策略——传统方法与 BPF 方法"><meta property="og:url" content="http://tech.wuzy.cn/p/performance-analysis-methodology/"><meta property="og:site_name" content="Eternal Sunshine"><meta property="og:description" content="本文将从系统维护者的角度对性能优化相关的方法论进行梳理，并特别阐述新生的 eBPF 给性能分析领域带来的影响。由于不同读者的知识领域并不完全相同，所以本文将不会涉及到具体实现，但只要读者有性能优化的需求，那么本文可能就会有所裨益。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://tech.wuzy.cn/p/performance-analysis-methodology/performance_analysis_overview_800%C3%97593.png"><meta property="article:published_time" content="2023-10-21T06:00:00.000Z"><meta property="article:modified_time" content="2023-10-22T03:34:04.879Z"><meta property="article:author" content="吴征阳"><meta property="article:tag" content="BPF"><meta property="article:tag" content="performance"><meta property="article:tag" content="Linux"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://tech.wuzy.cn/p/performance-analysis-methodology/performance_analysis_overview_800%C3%97593.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://tech.wuzy.cn/p/performance-analysis-methodology/"},"headline":"性能分析方法论及策略——传统方法与 BPF 方法","image":["http://tech.wuzy.cn/p/performance-analysis-methodology/performance_analysis_overview_800%C3%97593.png"],"datePublished":"2023-10-21T06:00:00.000Z","dateModified":"2023-10-22T03:34:04.879Z","author":{"@type":"Person","name":"吴征阳"},"publisher":{"@type":"Organization","name":"Eternal Sunshine","logo":{"@type":"ImageObject","url":"http://tech.wuzy.cn/img/logo_384×88.png"}},"description":"本文将从系统维护者的角度对性能优化相关的方法论进行梳理，并特别阐述新生的 eBPF 给性能分析领域带来的影响。由于不同读者的知识领域并不完全相同，所以本文将不会涉及到具体实现，但只要读者有性能优化的需求，那么本文可能就会有所裨益。"}</script><link rel="canonical" href="http://tech.wuzy.cn/p/performance-analysis-methodology/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Eternal Sunshine" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo_384%C3%9788.png" alt="Eternal Sunshine" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/p/performance-analysis-methodology/performance_analysis_overview_800%C3%97593.png" alt="性能分析方法论及策略——传统方法与 BPF 方法"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-21T06:00:00.000Z" title="10/21/2023, 2:00:00 PM">2023年10月21日</time>发表</span><span class="level-item"><time dateTime="2023-10-22T03:34:04.879Z" title="10/22/2023, 11:34:04 AM">2023年10月22日</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Cloud-Native/">Cloud Native</a></span><span class="level-item">1 小时读完 (共11818字)</span></div></div><h1 class="title is-3 is-size-4-mobile">性能分析方法论及策略——传统方法与 BPF 方法</h1><div class="content"><p>性能，性能，还是不得不谈的性能！无论是 PC、智能手机、云计算服务器，还是嵌入式系统，性能都扮演着至关重要的角色，是用户体验的关键，是决定业务成功与否的重要因素。</p>
<p>然而，要实现卓越的性能并不是一项轻而易举的任务。性能优化需要广泛的知识和技能，涵盖软件、硬件和许多其他领域。这是一场无休止的挑战，但也是一个充满激情的技术战场。</p>
<p>本文将从系统维护者的角度对性能优化相关的方法论进行梳理，并特别阐述新生的 eBPF 给性能分析领域带来的影响。由于不同读者的知识领域并不完全相同，所以本文将不会涉及到具体实现，但只要读者有性能优化的需求，那么本文可能就会有所裨益。</p>
<h2 id="性能分析方向"><a href="#性能分析方向" class="headerlink" title="性能分析方向"></a>性能分析方向</h2><p>下图是从用户态（🟥）和系统调用（🟨）到内核态（文件系统 I&#x2F;O：🟦、网络：🟩、调度和内存：🟧）和设备驱动（浅蓝）的全景图，其中每个色块代表的组成部分又分为若干个子系统，旁边的箭头指的是对应子系统有哪些可以用来执行分析的 BPF 工具。在如此众多的分析方向进行性能分析，如果没有方法论的指导，将必然会陷入迷茫。因此下文将细化到性能分析全景图的每个部分，阐述性能分析方法论及其策略。</p>
<p><img src="/p/performance-analysis-methodology/performance_analysis_overview.jpg" alt="性能分析全景图"></p>
<h2 id="性能分析方法论"><a href="#性能分析方法论" class="headerlink" title="性能分析方法论"></a>性能分析方法论</h2><h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>性能分析的最终目标就是优化用户体验、降低系统运行成本。这就需要观测软件和硬件资源是如何被使用的，以及从中定位可优化的部分。为了知道系统当前的工作状态，并确定优化措施是否生效，我们首先需要定义一些指标进行衡量。最常用的指标包括如下几项：</p>
<ul>
<li>延迟：多久可以完成一次请求或操作，通常以毫秒为单位。</li>
<li>速率：每秒操作或请求的速率。</li>
<li>吞吐量：通常指每秒传输的数据量，以比特（bit）或者字节（byte）为单位。</li>
<li>利用率：以百分比形式表示的某资源在一段时间内的繁忙程度。</li>
<li>成本：开销与性能的比值。</li>
</ul>
<h3 id="业务负载画像"><a href="#业务负载画像" class="headerlink" title="业务负载画像"></a>业务负载画像</h3><p>业务负载画像的目的是理解实际运行的业务负载，而并不需要对最终的性能结果进行分析，比如系统的延迟到底受到多少影响。</p>
<p>开展业务负载画像的常用步骤如下：</p>
<ol>
<li>负载是谁产生的（进程 ID、用户 ID、进程名、IP 地址）</li>
<li>负载为什么会产生（代码路径、调用栈、火焰图）</li>
<li>负载的组成是什么（IOPS、吞吐量、负载类型）</li>
<li>负载怎样随着时间发生变化（比较每个周期的摘要信息）</li>
</ol>
<h3 id="下钻分析"><a href="#下钻分析" class="headerlink" title="下钻分析"></a>下钻分析</h3><p>下钻分析的工作过程是从一个指标开始，然后将这个指标拆分成多个组成部分，再将最大的组份进一步拆分为更小的组份，不断重复这个过程直到定位出一个或多个根因。</p>
<p>下钻分析的常用步骤如下：</p>
<ol>
<li>从业务最高层级开始分析。</li>
<li>检查下一个层级的细节。</li>
<li>挑选出最感兴趣的部分或者线索。</li>
<li>如果问题还没有解决，跳转至第 2 步继续递归执行。</li>
</ol>
<p>下面举一个例子来讲解下钻分析如何将延迟分解为各个部分：</p>
<ol>
<li>一个请求的延迟是 100ms。</li>
<li>其中有 10ms 在 CPU 上运行（on CPU），90ms 消耗在脱离 CPU 的等待过程（off CPU）。</li>
<li>在脱离 CPU 等待的部分中，有 89ms 阻塞于文件系统上。</li>
<li>在文件系统的处理过程中，有 3ms 阻塞于锁上，而 86ms 阻塞于存储设备上。</li>
</ol>
<p>考虑一个类似的场景，但是问题的根本原因可能并不相同：</p>
<ol>
<li>一个应用花费了 89ms 阻塞在文件系统上。</li>
<li>文件系统花费了 78ms 阻塞在写操作上，11ms 阻塞在读操作上。</li>
<li>在文件系统写操作中，耗费了 77ms 阻塞在时间戳的更新上。</li>
</ol>
<p>此时，可以得出的结论是：更新时间戳是延迟的根源，而这是可以通过改变一个挂载选项禁掉的。这个分析结果说明的原因（系统配置问题）就和上一个场景（磁盘性能问题）完全不同。</p>
<h3 id="USE-方法论"><a href="#USE-方法论" class="headerlink" title="USE 方法论"></a>USE 方法论</h3><p>USE 方法论也可以用来进行资源分析。主要做法就是检查所有资源的使用率（<strong>U</strong>tilization）、饱和度（<strong>S</strong>aturation）、错误（<strong>E</strong>rrors）。以重要的问题作为开始，反过来再去找出为什么它重要。</p>
<h3 id="检查清单法"><a href="#检查清单法" class="headerlink" title="检查清单法"></a>检查清单法</h3><p>在系统出现性能问题时，一个茫然无措的管理员可以通过一系列成规范的命令快速检测系统工作状态（开始检测的 60 秒内）。下面就是这些命令及其含义。</p>
<table>
<thead>
<tr>
<th></th>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>uptime</code></td>
<td>1 分钟、5 分钟、15 分钟内的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Load_(computing)">平均负载</a></td>
</tr>
<tr>
<td>2</td>
<td><code>dmesg | tail</code></td>
<td>过去 10 条操作系统日志</td>
</tr>
<tr>
<td>3</td>
<td><code>vmstat 1</code></td>
<td>虚拟内存相关：等待执行的进程数、空闲内存、交换内存、各种状态的 CPU 运行时间（<strong>us</strong>er time、<strong>sy</strong>stem time、<strong>id</strong>le、<strong>wa</strong>it I&#x2F;O 和 <strong>st</strong>olen time）</td>
</tr>
<tr>
<td>4</td>
<td><code>mpstat -P ALL 1</code></td>
<td>每个 CPU 分解到各个 CPU 状态下的时间</td>
</tr>
<tr>
<td>5</td>
<td><code>pidstat 1</code></td>
<td>按进程逐秒展示 CPU 的使用情况</td>
</tr>
<tr>
<td>6</td>
<td><code>iostat -xz 1</code></td>
<td>存储设备 I&#x2F;O 相关：每秒向设备发送的读&#x2F;写次数和字节数、I&#x2F;O 的平均响应时间、设备请求队列的平均长度、设备使用率</td>
</tr>
<tr>
<td>7</td>
<td><code>free -m</code></td>
<td>可用内存</td>
</tr>
<tr>
<td>8</td>
<td><code>sar -n DEV 1</code></td>
<td>各网络设备吞吐量</td>
</tr>
<tr>
<td>9</td>
<td><code>sar -n TCP,ETCP 1</code></td>
<td>接受连接速率、创建连接速率、每秒 TCP 重传量</td>
</tr>
<tr>
<td>10</td>
<td><code>top</code></td>
<td>综合上述工具的检测手段，用于二次确认</td>
</tr>
</tbody></table>
<p>特别地，BPF 工具也能用于性能分析和检查，并会有不一样的视角和效果。BCC 是基于 BPF 实现的 Linux 内核技术，可以广泛用于 I&#x2F;O 分析、网络操作和系统监控。当前 BCC 中已经有很多支持即插即用的工具，能够在多个方面实现系统监控，所以这里也有一组由 BCC 工具组成的检查清单。</p>
<table>
<thead>
<tr>
<th></th>
<th>BCC 工具</th>
<th>监测维度</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>execsnoop</code></td>
<td>创建新进程</td>
</tr>
<tr>
<td>2</td>
<td><code>opensnoop</code></td>
<td>打开文件</td>
</tr>
<tr>
<td>3</td>
<td><code>ext4slower</code>（或 <code>btrfs*</code>、<code>xfs*</code>、<code>zfs*</code>）</td>
<td>文件系统延迟</td>
</tr>
<tr>
<td>4</td>
<td><code>biolatency</code></td>
<td>磁盘 I&#x2F;O 延迟分布</td>
</tr>
<tr>
<td>5</td>
<td><code>biosnoop</code></td>
<td>磁盘 I&#x2F;O 延迟详细信息</td>
</tr>
<tr>
<td>6</td>
<td><code>cachestat</code></td>
<td>文件系统缓存性能</td>
</tr>
<tr>
<td>7</td>
<td><code>tcpconnect</code></td>
<td>TCP 发起连接</td>
</tr>
<tr>
<td>8</td>
<td><code>tcpaccept</code></td>
<td>TCP 接受连接</td>
</tr>
<tr>
<td>9</td>
<td><code>tcpretrans</code></td>
<td>TCP 重传</td>
</tr>
<tr>
<td>10</td>
<td><code>runqlat</code></td>
<td>调度延迟</td>
</tr>
<tr>
<td>11</td>
<td><code>profile</code></td>
<td>CPU 使用情况</td>
</tr>
</tbody></table>
<h2 id="性能分析策略"><a href="#性能分析策略" class="headerlink" title="性能分析策略"></a>性能分析策略</h2><p>一般情况下，在出现性能问题时，管理员可以通过上述某些检查清单初步定位系统问题。但是，定位到问题所在的位置之后呢？我们应该如何继续“下钻”下去？这个时候就需要针对不同的子系统采取不同的分析策略。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="CPU-分析策略"><a href="#CPU-分析策略" class="headerlink" title="CPU 分析策略"></a>CPU 分析策略</h4><ol>
<li>先保证待分析的对象处于 CPU 运行状态。检查系统的整体 CPU 利用率（使用 <code>mpstat(1)</code>），并且保证每个 CPU 都处于在线状态（检查是否有些 CPU 由于某些原因处于下线状态）。</li>
<li>确认系统负载确实受限于 CPU。<ol>
<li>确认系统中所有 CPU 的使用率是否都很高，还是仅某个 CPU 使用率高（<code>mpstat(1)</code>）。</li>
<li>检查系统中运行队列的延迟（使用 BCC 工具 <code>mnqlat(1)</code>）。系统中的一些软件限制（比如容器的设置）可以限制进程所能使用的 CPU 资源，进而导致某些程序在空闲系统上仍然受限于 CPU。通过分析运行队列延迟可以识别这种类型的反常情景。</li>
</ol>
</li>
<li>先量化整个系统中的 CPU 使用量的百分比，然后再按进程、CPU 模式、CPU ID 来分解。这可以用传统工具来进行（如 <code>mpstat(1)</code>、<code>top(1)</code>等）。可以通过某种模式或者某个 CPU 的高使用率情况寻找某个进程。<ol>
<li>如果系统时间（system time）占比高，那么可按照进程和系统调用类型来统计系统调用的频率和数量，同时检查系统调用的参数来寻找需要优化的地方（使用 <code>perf(1)</code>、<a target="_blank" rel="noopener" href="https://github.com/iovisor/bpftrace">bpftrace</a> 单行程序，以及 BCC 工具 <code>sysstat(8)</code>）。</li>
</ol>
</li>
<li>用性能剖析器（Profiler）来对应用程序的调用栈信息进行采样，再用 <a target="_blank" rel="noopener" href="https://www.brendangregg.com/flamegraphs.html">CPU 火焰图（Flame Graphs）</a>来展示。通过分析火焰图能够捕获到很多 CPU 问题。</li>
<li>针对某个 CPU 使用率高的任务，可考虑开发一些定制工具来获取更多的上下文信息。性能剖析器通常可以展示哪些函数正在运行，但是不能展示调用参数和函数内部的信息。理解 CPU 用量时可能需要这些调用栈信息，例如：<ol>
<li>内核态：如果某个文件系统针对文件进行 <code>stat()</code> 消耗了很多 CPU 资源，那么文件名是什么？这可以用 BCC 工具 <code>statsnoop(8)</code> 来获取，也可以自行通过 BPF 工具获取。</li>
<li>用户态：如果某个应用程序忙于处理请求，那么这些请求到底是什么？如果没有针对这个程序的特定工具，可以考虑通过 <a target="_blank" rel="noopener" href="https://lwn.net/Articles/753601/">USDT 或 uprobe</a> 来开发这种工具。</li>
</ol>
</li>
<li>测量硬中断的资源消耗，但这些信息可能对基于定时器的性能剖析器不可见。可以使用 BCC 工具 <code>hardirqs(1)</code> 解决这个问题。</li>
<li>利用程序监控计数器（PMCs，Performance Monitoring Counters）测量每时钟周期内的 CPU 指令执行量（IPC），以理解宏观层面 CPU 的阻塞情况（使用 <code>perf(1)</code>）。还有其他的 PMC 工具可以进一步分析低缓存命中率（如 BCC 工具 <code>llcstat(8)</code>）或温控导致的阻塞等问题。</li>
</ol>
<h4 id="CPU-分析相关传统工具"><a href="#CPU-分析相关传统工具" class="headerlink" title="CPU 分析相关传统工具"></a>CPU 分析相关传统工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>uptime</code></td>
<td>内核统计</td>
<td>平均负载和系统运行时间</td>
</tr>
<tr>
<td><code>top</code></td>
<td>内核统计</td>
<td>进程的 CPU 时间和系统层面的 CPU 模式时间</td>
</tr>
<tr>
<td><code>mpstat</code></td>
<td>内核统计</td>
<td>显示各 CPU 的每个 CPU 模式下的时间</td>
</tr>
<tr>
<td><code>perf</code></td>
<td>内核统计、硬件统计、事件跟踪</td>
<td>对调用栈和事件统计进行定时采样，以及对 PMCs、tracepoint、USDT 探针、kprobe 和 uprobe 进行跟踪</td>
</tr>
<tr>
<td><code>Ftrace</code></td>
<td>内核统计、事件跟踪</td>
<td>内核函数计数统计和 kprobe、uprobe 的事件跟踪</td>
</tr>
</tbody></table>
<h4 id="CPU-分析相关-BPF-工具"><a href="#CPU-分析相关-BPF-工具" class="headerlink" title="CPU 分析相关 BPF 工具"></a>CPU 分析相关 BPF 工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>execsnoop</code></td>
<td>调度</td>
<td>新进程的执行情况</td>
</tr>
<tr>
<td><code>exitsnoop</code></td>
<td>调度</td>
<td>进程的寿命和退出原因</td>
</tr>
<tr>
<td><code>runqlat</code></td>
<td>调度</td>
<td>统计 CPU 运行队列的延迟</td>
</tr>
<tr>
<td><code>runqlen</code></td>
<td>调度</td>
<td>统计 CPU 运行队列的长度</td>
</tr>
<tr>
<td><code>runqslower</code></td>
<td>调度</td>
<td>超过运行队列等待时长阈值的进程</td>
</tr>
<tr>
<td><code>cpudist</code></td>
<td>调度</td>
<td>统计 on-CPU 的时间</td>
</tr>
<tr>
<td><code>cpufreq</code></td>
<td>CPU</td>
<td>通过进程采样 CPU 频率</td>
</tr>
<tr>
<td><code>profile</code></td>
<td>CPU</td>
<td>采样 CPU 调用栈</td>
</tr>
<tr>
<td><code>offcputime</code></td>
<td>调度</td>
<td>统计 off-CPU 的调用栈和时间</td>
</tr>
<tr>
<td><code>syscount</code></td>
<td>系统调用</td>
<td>按类型和进程统计系统调用</td>
</tr>
<tr>
<td><code>argdist</code></td>
<td>系统调用</td>
<td>用于系统调用分析的工具</td>
</tr>
<tr>
<td><code>trace</code></td>
<td>系统调用</td>
<td>用于系统调用分析的工具</td>
</tr>
<tr>
<td><code>funccount</code></td>
<td>软件</td>
<td>统计函数调用</td>
</tr>
<tr>
<td><code>softirqs</code></td>
<td>中断</td>
<td>统计软中断时间</td>
</tr>
<tr>
<td><code>hardirqs</code></td>
<td>中断</td>
<td>统计硬中断时间</td>
</tr>
<tr>
<td><code>smpcalls</code></td>
<td>内核</td>
<td>SMP 远程 CPU 调用时间</td>
</tr>
<tr>
<td><code>llcstat</code></td>
<td>PMCs</td>
<td>按进程统计最后一级缓存（LLC）命中率</td>
</tr>
</tbody></table>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="内存分析策略"><a href="#内存分析策略" class="headerlink" title="内存分析策略"></a>内存分析策略</h4><ol>
<li>检查系统信息中是否有 OOM Killer 杀掉进程的信息（使用 <code>dmesg(1)</code>）。</li>
<li>检查系统中是否配置了换页，以及使用的换页空间大小。并且检查这些换页设备是否有活跃的 I&#x2F;O 操作（使用 <code>swap(1)</code>、<code>iostat(1)</code>、<code>vmstat(1)</code>）。</li>
<li>检查系统中空闲内存的数量，以及整个系统的缓存使用情况（使用 <code>free(1)</code>）。</li>
<li>按进程检查内存用量（使用 <code>top(1)</code> 和 <code>ps(1)</code>）。</li>
<li>检查系统中缺页错误的发生频率，并且检查缺页错误发生时的调用栈信息，这可以解释常驻内存大小（RSS，Resident Set Size）增长的原因。</li>
<li>检查缺页错误和哪些文件有关。</li>
<li>通过跟踪 <code>brk()</code> 和 <code>mmap()</code> 调用来从另一个角度审查内存用量。</li>
<li>使用 PMC 测量硬件缓存命空率和内存访问，以便分析导致内存 I&#x2F;O 发生的函数和指令信息（使用 <code>perf(1)</code>）。</li>
</ol>
<h4 id="内存分析相关传统工具"><a href="#内存分析相关传统工具" class="headerlink" title="内存分析相关传统工具"></a>内存分析相关传统工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>dmesg</code></td>
<td>内核日志</td>
<td>OOM killer 事件详情</td>
</tr>
<tr>
<td><code>swapon</code></td>
<td>内核统计</td>
<td>换页的使用情况</td>
</tr>
<tr>
<td><code>free</code></td>
<td>内核统计</td>
<td>系统范围内内存使用情况</td>
</tr>
<tr>
<td><code>ps</code></td>
<td>内核统计</td>
<td>进程统计信息，包括内存使用情况</td>
</tr>
<tr>
<td><code>pmap</code></td>
<td>内核统计</td>
<td>按段（segment）查看进程的内存使用情况</td>
</tr>
<tr>
<td><code>vmstat</code></td>
<td>内核统计</td>
<td>各种统计数据，包括内存情况</td>
</tr>
<tr>
<td><code>sar</code></td>
<td>内核统计</td>
<td>页面错误和页面扫描速率</td>
</tr>
<tr>
<td><code>perf</code></td>
<td>软件事件、硬件统计、硬件采样</td>
<td>内存相关 PMC 统计和事件采样</td>
</tr>
</tbody></table>
<h4 id="内存分析相关-BPF-工具"><a href="#内存分析相关-BPF-工具" class="headerlink" title="内存分析相关 BPF 工具"></a>内存分析相关 BPF 工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>oomkill</code></td>
<td>OOM</td>
<td>显示 OOM 事件的额外信息</td>
</tr>
<tr>
<td><code>memleak</code></td>
<td>调度</td>
<td>统计可能的内存泄漏代码路径</td>
</tr>
<tr>
<td><code>mmapsnoop</code></td>
<td>系统调用</td>
<td>跟踪系统范围内的 <code>mmap(2)</code> 调用</td>
</tr>
<tr>
<td><code>brkstack</code></td>
<td>系统调用</td>
<td>显示带有用户调用栈的 <code>brk()</code> 调用</td>
</tr>
<tr>
<td><code>shmsnoop</code></td>
<td>系统调用</td>
<td>显示共享内存调用的详细信息</td>
</tr>
<tr>
<td><code>faults</code></td>
<td>页错误</td>
<td>按用户调用栈统计页面错误</td>
</tr>
<tr>
<td><code>ffaults</code></td>
<td>页错误</td>
<td>按文件名统计页面错误</td>
</tr>
<tr>
<td><code>vmscan</code></td>
<td>VM</td>
<td>测量 VM 扫描程序收缩和回收时间</td>
</tr>
<tr>
<td><code>drsnoop</code></td>
<td>VM</td>
<td>跟踪直接回收事件，显示延迟</td>
</tr>
<tr>
<td><code>swapin</code></td>
<td>VM</td>
<td>按进程统计页换入信息</td>
</tr>
<tr>
<td><code>hfaults</code></td>
<td>页错误</td>
<td>按进程统计巨页的缺页错误信息</td>
</tr>
</tbody></table>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件系统分析策略"><a href="#文件系统分析策略" class="headerlink" title="文件系统分析策略"></a>文件系统分析策略</h4><ol>
<li>先识别系统中挂载的文件系统。可使用 <code>df(1)</code> 和 <code>mount(8)</code>。</li>
<li>检查挂载的文件系统的容量。某些文件系统在接近 100％ 使用量的时候会有性能下降的情况，这是因为它们采用的是寻找空余块的算法（例如 FFS、ZFS）。</li>
<li>在用 BPF 工具分析自己不熟悉的生产环境负载之前，可先用这些工具来分析一个已知的负载。可以找一台空闲的机器，产生一种固定的负载，再使用类似 <code>fio(1)</code> 这样的工具来分析。</li>
<li>使用 <code>opensnoop(8)</code> 来观察正在打开哪些文件。</li>
<li>使用 <code>filefile(8)</code> 来检查是否存在短期文件的问题。</li>
<li>查找非常慢的文件系统操作，按进程和文件名详细观察。这可能可以帮助找到一个可以消除的负载来源，或者定量分析某个性能问题以便进行后续调优。<ol>
<li>使用 <code>ext4slower(8)</code>、<code>btrfsslower(8)</code>、<code>zfsslower(8)</code> 等，或者使用—个性能损耗可能偏高但是通用的工具，如 <code>fileslower(8)</code>。</li>
</ol>
</li>
<li>检查文件系统的延迟分布（利用 <code>ext4dist(8)</code>、<code>btrfsdist(8)</code>、<code>zfsdist(8)</code> 等工具）。这有可能会显示导致性能问题的延迟呈双峰分布或者离群的情况。这些问题可以继续用其他工具来进一步分析。</li>
<li>检查一段时间内页缓存的命中率（使用 <code>cachestat(8)</code>）。检查是否其他类型的负载会改变命中率，或者是否有调优手段可以用来优化。</li>
<li>使用 <code>vfsstat(8)</code> 来比较逻辑 I&#x2F;O 和 <code>iostat(1)</code> 提供的物理 I&#x2F;O 的区别。理想的情况是，逻辑 I&#x2F;O 的数量应该远大于物理 I&#x2F;O 的，这意味着缓存正在发挥作用。</li>
</ol>
<h4 id="文件系统相关传统工具"><a href="#文件系统相关传统工具" class="headerlink" title="文件系统相关传统工具"></a>文件系统相关传统工具</h4><p>传统性能分析一般只关注磁盘的性能，所以几乎没有什么传统工具可以用来观测文件系统。下面是一些比较相关的工具。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>df</code></td>
<td>文件系统</td>
<td>磁盘空间使用情况、磁盘挂载点</td>
</tr>
<tr>
<td><code>mount</code></td>
<td>文件系统</td>
<td>显示和管理文件系统挂载点</td>
</tr>
<tr>
<td><code>strace</code></td>
<td>进程</td>
<td>跟踪并记录进程的系统调用和信号</td>
</tr>
<tr>
<td><code>perf</code></td>
<td>软件性能</td>
<td>丰富的性能分析工具，包括性能计数器、采样和跟踪功能，用于分析 CPU 和内存性能</td>
</tr>
<tr>
<td><code>fatrace</code></td>
<td>文件系统</td>
<td>跟踪文件系统活动，包括文件的创建、删除、访问和关闭等，可用于监视文件操作事件</td>
</tr>
</tbody></table>
<h4 id="文件系统相关-BPF-工具"><a href="#文件系统相关-BPF-工具" class="headerlink" title="文件系统相关 BPF 工具"></a>文件系统相关 BPF 工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>opensnoop</code></td>
<td>系统调用</td>
<td>跟踪文件的打开操作</td>
</tr>
<tr>
<td><code>statsnoop</code></td>
<td>系统调用</td>
<td>跟踪 <code>stat(2)</code> 调用</td>
</tr>
<tr>
<td><code>syncsnoop</code></td>
<td>系统调用</td>
<td>跟踪 <code>sync(2)</code> 和相关调用</td>
</tr>
<tr>
<td><code>mmapfiles</code></td>
<td>系统调用</td>
<td>统计 <code>mmap(2)</code> 文件的数量</td>
</tr>
<tr>
<td><code>scread</code></td>
<td>系统调用</td>
<td>统计 <code>read(2)</code> 文件的数量</td>
</tr>
<tr>
<td><code>fmapfault</code></td>
<td>页缓存</td>
<td>统计文件映射的缺页错误数量</td>
</tr>
<tr>
<td><code>filelife</code></td>
<td>VFS</td>
<td>跟踪生命周期较短的文件，逐秒记录其生命周期</td>
</tr>
<tr>
<td><code>vfsstat</code></td>
<td>VFS</td>
<td>常见 VFS 操作的统计信息</td>
</tr>
<tr>
<td><code>vfscount</code></td>
<td>VFS</td>
<td>统计所有 VFS 操作的数量</td>
</tr>
<tr>
<td><code>vfssize</code></td>
<td>VFS</td>
<td>VFS 读写的大小</td>
</tr>
<tr>
<td><code>fsrwstat</code></td>
<td>VFS</td>
<td>按文件系统类型的 VFS 读写</td>
</tr>
<tr>
<td><code>fileslower</code></td>
<td>VFS</td>
<td>慢速文件读写</td>
</tr>
<tr>
<td><code>filetop</code></td>
<td>VFS</td>
<td>按 IOPS 和字节数统计使用频率最高的文件</td>
</tr>
<tr>
<td><code>filetype</code></td>
<td>VFS</td>
<td>按文件类型和进程统计 VFS 读写操作</td>
</tr>
<tr>
<td><code>writesync</code></td>
<td>VFS</td>
<td>通过同步标志（sync）进行的常规文件写入</td>
</tr>
<tr>
<td><code>cachestat</code></td>
<td>页缓存</td>
<td>页面缓存统计</td>
</tr>
<tr>
<td><code>writeback</code></td>
<td>页缓存</td>
<td>写回事件及其延迟</td>
</tr>
<tr>
<td><code>dcstat</code></td>
<td>Dcache</td>
<td>目录缓存命中统计</td>
</tr>
<tr>
<td><code>dcsnoop</code></td>
<td>Dcache</td>
<td>跟踪目录缓存查找</td>
</tr>
<tr>
<td><code>mountsnoop</code></td>
<td>VFS</td>
<td>跟踪系统范围内的挂载和卸载操作</td>
</tr>
<tr>
<td><code>xfsslower</code></td>
<td>XFS</td>
<td>统计慢速 XFS 操作</td>
</tr>
<tr>
<td><code>xfsdist</code></td>
<td>XFS</td>
<td>常见 XFS 操作延迟直方图</td>
</tr>
<tr>
<td><code>ext4dist</code></td>
<td>ext4</td>
<td>常见 ext4 操作延迟直方图</td>
</tr>
<tr>
<td><code>icstat</code></td>
<td>Icache</td>
<td>inode 缓存命中统计</td>
</tr>
<tr>
<td><code>bufgrow</code></td>
<td>Buffer cache</td>
<td>按进程和缓存大小统计缓冲区缓存的增长</td>
</tr>
<tr>
<td><code>readahead</code></td>
<td>VFS</td>
<td>预读取的命中率和效率</td>
</tr>
</tbody></table>
<h3 id="磁盘-I-O"><a href="#磁盘-I-O" class="headerlink" title="磁盘 I&#x2F;O"></a>磁盘 I&#x2F;O</h3><h4 id="磁盘-I-O-分析策略"><a href="#磁盘-I-O-分析策略" class="headerlink" title="磁盘 I&#x2F;O 分析策略"></a>磁盘 I&#x2F;O 分析策略</h4><ol>
<li>对应用程序性能问题来说，可以先按之前的步骤从文件系统层着手分析。</li>
<li>检查基本的磁盘性能指标：请求时长、IOPS、使用率（使用 <code>iostat(1)</code>）。注意高使用率（仅作为参考指标）、高于常值的请求时长（延迟）和 IOPS 情况。</li>
<li>跟踪块 I&#x2F;O 延迟的分布情况，检查是否有多峰分布的情况，以及延时超标的情况（使用 BCC 工具 <code>biolatency(8)</code>）。</li>
<li>单独跟踪具体的块 I&#x2F;O，找寻系统中的一些行为模式，例如是否有大量写入请求导致读队列增长等（使用 BCC 工具 <code>biosnoop(8)</code>）。</li>
</ol>
<h4 id="磁盘-I-O-分析相关传统工具"><a href="#磁盘-I-O-分析相关传统工具" class="headerlink" title="磁盘 I&#x2F;O 分析相关传统工具"></a>磁盘 I&#x2F;O 分析相关传统工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>iostat</code></td>
<td>磁盘活动</td>
<td>统计磁盘活动信息</td>
</tr>
<tr>
<td><code>perf</code></td>
<td>块 I&#x2F;O</td>
<td>用于块 I&#x2F;O 设备的跟踪</td>
</tr>
<tr>
<td><code>blktrace</code></td>
<td>块设备</td>
<td>用于跟踪块设备 I&#x2F;O 操作事件</td>
</tr>
<tr>
<td>SCSI 日志</td>
<td>SCSI 设备</td>
<td>使用系统日志查找错误超时问题</td>
</tr>
</tbody></table>
<h4 id="磁盘-I-O-分析相关-BPF-工具"><a href="#磁盘-I-O-分析相关-BPF-工具" class="headerlink" title="磁盘 I&#x2F;O 分析相关 BPF 工具"></a>磁盘 I&#x2F;O 分析相关 BPF 工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>biolatency</code></td>
<td>块 I&#x2F;O</td>
<td>统计块 I&#x2F;O 的延迟并生成直方图</td>
</tr>
<tr>
<td><code>biosnoop</code></td>
<td>块 I&#x2F;O</td>
<td>使用 PID 和延迟跟踪块 I&#x2F;O</td>
</tr>
<tr>
<td><code>biotop</code></td>
<td>块 I&#x2F;O</td>
<td>按进程统计块 I&#x2F;O（类似 top 工具）</td>
</tr>
<tr>
<td><code>bitesize</code></td>
<td>块 I&#x2F;O</td>
<td>按进程统计磁盘 I&#x2F;O 大小的直方图</td>
</tr>
<tr>
<td><code>seeksize</code></td>
<td>块 I&#x2F;O</td>
<td>统计请求的 I&#x2F;O 寻址距离</td>
</tr>
<tr>
<td><code>biopattern</code></td>
<td>块 I&#x2F;O</td>
<td>识别随机或顺序磁盘访问模式</td>
</tr>
<tr>
<td><code>biostacks</code></td>
<td>块 I&#x2F;O</td>
<td>显示初始化调用栈的磁盘 I&#x2F;O</td>
</tr>
<tr>
<td><code>bioerr</code></td>
<td>块 I&#x2F;O</td>
<td>跟踪磁盘错误</td>
</tr>
<tr>
<td><code>mdflush</code></td>
<td>MD（磁盘阵列）</td>
<td>跟踪 MD 刷新请求</td>
</tr>
<tr>
<td><code>iosched</code></td>
<td>I&#x2F;O 调度</td>
<td>统计 I&#x2F;O 调度器的延迟</td>
</tr>
<tr>
<td><code>scsilatency</code></td>
<td>SCSI</td>
<td>SCSI 命令延迟分布</td>
</tr>
<tr>
<td><code>scsiresult</code></td>
<td>SCSI</td>
<td>SCSI 命令结果代码</td>
</tr>
<tr>
<td><code>nvmelatency</code></td>
<td>NVME</td>
<td>统计 NVME 驱动程序命令延迟</td>
</tr>
</tbody></table>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络分析策略"><a href="#网络分析策略" class="headerlink" title="网络分析策略"></a>网络分析策略</h4><p>从对负载定性分析开始，找出低效之处（第 1、2 步），然后检查各接口的限制（第 3 步），以及不同的延迟源（第 4、5、6 步）。此后，可能可以使用实验分析法（第 7 步），但这可能会对生产负载产生影响。接下来可以使用更高级和自定义的分析工具（第 8、9 步）。</p>
<ol>
<li>使用基于计数器的工具获取基本的网络统计信息：网络包速率和吞吐量。如果正在使用 TCP，那么查看 TCP 连接率和 TCP 重传率（使用 <code>ss(8)</code>、<code>nstat(8)</code>、<code>netstat(1)</code> 和 <code>sar(1)</code>）。</li>
<li>通过跟踪新 TCP 连接的建立和时长来定性分析负载，并且寻找低效之处（使用 BCC 工具 <code>tcplife(8)</code>）。例如读取远端资源而频繁建立的连接，可以通过本地缓存来解决。</li>
<li>检查是否到达了网卡吞吐量上限。可以使用 <code>sar(1)</code> 或者 <code>nicstat(1)</code> 中的接口使用率指标。</li>
<li>跟踪 TCP 重传和其他的不常见 TCP 事件（使用 BCC 工具 <code>tcpretrans(8)</code>、<code>tcpdrop(8)</code>，以及 <code>skb:kfree_skb</code> 跟踪点）。</li>
<li>测量主机 DNS 解析延迟。这往往是常见的性能问题（使用 BCC 工具 <code>gethostlatency(8)</code>）。</li>
<li>从各个不同的角度测量网络延迟：连接延迟、首字节延迟、调用栈内不各层之间的延迟等。<ol>
<li>注意，网络延迟测试在有不同负载的情况下可能由于网络中的缓冲区膨胀问题而有大幅变化（排队导致的延迟）。应该在有负载时和空闲时中分别测量这些延迟以进行比较。</li>
</ol>
</li>
<li>使用负载生成工具来探索主机之间的网络吞吐量上限，同时检查在已知负载情况下发生的网络事件（使用 <code>iperf(1)</code> 和 <code>netperf(1)</code>）。</li>
<li>使用高频率的 CPU 性能分析抓取内核调用栈信息，以量化 CPU 资源在网络协议和驱动程序之间的使用情况。</li>
<li>使用 tracepoint 和 kprobe 来探索网络协议栈的内部情况。</li>
</ol>
<p>在监测内核网络事件时需要注意：</p>
<ul>
<li>网络事件可能不在应用程序上下文中触发。收到数据包时，可能是其他线程正在 CPU 上执行，而且这时可能有 TCP 连接建立和状态的改变。如果在这些事件发生时检查在 CPU 上执行的 PID 和进程名，并不能获取到对应的应用程序信息。这时需要选择那些在应用程序上下文中触发的事件，或者使用某个标识符（例如使用 <code>sock</code> 结构体）来缓存应用程序上下文信息，后续再读取。</li>
<li>系统中可能存在快路径和慢路径之分。如果一段程序只跟踪其中一个路径，看起来也能够正常工作。所以这个时候就需要使用一些已知的负载来确保包数量和字节数量与预期相符。</li>
<li>TCP 中有满套接字（full sockets）和不满套接字（non-full sockets）之分：不满套接字指的是三次握手没有完成之前的套接字，或者是处于 <code>TIME_WAIT</code> 状态的套接字。在不满套接字中，socket 结构体的有些字段可能处于无效状态。</li>
</ul>
<h4 id="网络分析相关传统工具"><a href="#网络分析相关传统工具" class="headerlink" title="网络分析相关传统工具"></a>网络分析相关传统工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ss</code></td>
<td>内核层面统计</td>
<td>套接字统计</td>
</tr>
<tr>
<td><code>ip</code></td>
<td>内核层面统计</td>
<td>IP 统计</td>
</tr>
<tr>
<td><code>nstat</code></td>
<td>内核层面统计</td>
<td>网络栈统计</td>
</tr>
<tr>
<td><code>netstat</code></td>
<td>内核层面统计</td>
<td>综合工具，用于统计网络协议栈的信息和状态</td>
</tr>
<tr>
<td><code>sar</code></td>
<td>内核层面统计</td>
<td>综合工具，用于统计网络和其他信息</td>
</tr>
<tr>
<td><code>nicstat</code></td>
<td>内核层面统计</td>
<td>网卡信息统计</td>
</tr>
<tr>
<td><code>ethtool</code></td>
<td>驱动层面统计</td>
<td>网卡驱动统计</td>
</tr>
<tr>
<td><code>tcpdump</code></td>
<td>抓包</td>
<td>捕获数据包以供分析</td>
</tr>
<tr>
<td><code>iperf</code></td>
<td>微基准测试</td>
<td>网络分析</td>
</tr>
<tr>
<td><code>netperf</code></td>
<td>微基准测试</td>
<td>网络分析</td>
</tr>
<tr>
<td><code>ping</code></td>
<td>ICMP</td>
<td>网络可达性分析</td>
</tr>
<tr>
<td><code>traceroute</code></td>
<td>路由发现</td>
<td>路由分析</td>
</tr>
<tr>
<td><code>/proc</code> 文件系统</td>
<td>内核层面统计</td>
<td>统计多种网络信息</td>
</tr>
</tbody></table>
<h4 id="网络分析相关-BPF-工具"><a href="#网络分析相关-BPF-工具" class="headerlink" title="网络分析相关 BPF 工具"></a>网络分析相关 BPF 工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>sockstat</code></td>
<td>套接字</td>
<td>高层级的套接字统计</td>
</tr>
<tr>
<td><code>sofamily</code></td>
<td>套接字</td>
<td>按进程统计新套接字的地址族</td>
</tr>
<tr>
<td><code>soprotocol</code></td>
<td>套接字</td>
<td>按进程统计新套接字的传输协议</td>
</tr>
<tr>
<td><code>soconnect</code></td>
<td>套接字</td>
<td>跟踪套接字 IP 协议连接过程的详细信息</td>
</tr>
<tr>
<td><code>soaccept</code></td>
<td>套接字</td>
<td>跟踪套接字 IP 协议接受过程的详细信息</td>
</tr>
<tr>
<td><code>socketio</code></td>
<td>套接字</td>
<td>统计套接字细节与 I&#x2F;O</td>
</tr>
<tr>
<td><code>socksize</code></td>
<td>套接字</td>
<td>按进程统计套接字 I&#x2F;O 大小的直方图</td>
</tr>
<tr>
<td><code>sormem</code></td>
<td>套接字</td>
<td>统计套接字接收缓冲区使用情况和溢出</td>
</tr>
<tr>
<td><code>soconnlat</code></td>
<td>套接字</td>
<td>统计 IP 套接字连接延迟，并附带调用栈</td>
</tr>
<tr>
<td><code>so1stbyte</code></td>
<td>套接字</td>
<td>统计 IP 套接字首字节延迟</td>
</tr>
<tr>
<td><code>tcpconnect</code></td>
<td>TCP</td>
<td>跟踪 TCP 主动连接（<code>connect()</code>）</td>
</tr>
<tr>
<td><code>tcpaccept</code></td>
<td>TCP</td>
<td>跟踪 TCP 被动连接（<code>accept()</code>）</td>
</tr>
<tr>
<td><code>tcplife</code></td>
<td>TCP</td>
<td>跟踪 TCP 会话生命周期，包括连接详细信息</td>
</tr>
<tr>
<td><code>tcptop</code></td>
<td>TCP</td>
<td>按主机地址显示 TCP 发送&#x2F;接收吞吐量</td>
</tr>
<tr>
<td><code>tcpretrans</code></td>
<td>TCP</td>
<td>跟踪 TCP 重传，包括地址和 TCP 状态</td>
</tr>
<tr>
<td><code>tcpsynbl</code></td>
<td>TCP</td>
<td>统计 TCP SYN 队列直方图</td>
</tr>
<tr>
<td><code>tcpwin</code></td>
<td>TCP</td>
<td>跟踪 TCP 发送拥塞窗口参数</td>
</tr>
<tr>
<td><code>tcpnagle</code></td>
<td>TCP</td>
<td>跟踪 TCP Nagle 使用和传输延迟</td>
</tr>
<tr>
<td><code>udpconnect</code></td>
<td>UDP</td>
<td>跟踪本地主机的新 UDP 连接</td>
</tr>
<tr>
<td><code>gethostlatency</code></td>
<td>DNS</td>
<td>通过库调用跟踪 DNS 查找延迟</td>
</tr>
<tr>
<td><code>ipecn</code></td>
<td>IP</td>
<td>跟踪入站（inbound）显式拥塞通知</td>
</tr>
<tr>
<td><code>superping</code></td>
<td>ICMP</td>
<td>从网络协议栈中测量 ICMP 回显时间</td>
</tr>
<tr>
<td><code>qdisc-fq (...)</code></td>
<td>qdisc</td>
<td>统计 FQ qdisc 队列延迟</td>
</tr>
<tr>
<td><code>netsize</code></td>
<td>网络</td>
<td>统计网络设备 I&#x2F;O 大小</td>
</tr>
<tr>
<td><code>nettxlat</code></td>
<td>网络</td>
<td>统计网络设备传输延迟</td>
</tr>
<tr>
<td><code>skbdrop</code></td>
<td>skbs</td>
<td>跟踪 <code>sk_buff</code> 丢弃，包括内核调用栈</td>
</tr>
<tr>
<td><code>skblife</code></td>
<td>skbs</td>
<td>跟踪 <code>sk_buff</code> 的生命周期，包括调用栈内延迟</td>
</tr>
<tr>
<td><code>ieee80211scan</code></td>
<td>WiFi</td>
<td>跟踪 IEEE 802.11 WiFi 扫描</td>
</tr>
</tbody></table>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>这里所说的安全指的是安全分析、安全监控和策略执行。目前也有一些 BPF 工具可用于这个目的。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>execsnoop</code></td>
<td>系统调用</td>
<td>列出新进程的执行情况</td>
</tr>
<tr>
<td><code>elfsnoop</code></td>
<td>内核</td>
<td>显示 ELF 文件加载情况</td>
</tr>
<tr>
<td><code>modsnoop</code></td>
<td>内核</td>
<td>显示内核模块加载情况</td>
</tr>
<tr>
<td><code>bashreadline</code></td>
<td>bash</td>
<td>列出输入的 bash shell 命令</td>
</tr>
<tr>
<td><code>shellsnoop</code></td>
<td>shells</td>
<td>镜像 shell 的输出</td>
</tr>
<tr>
<td><code>ttysnoop</code></td>
<td>TTY</td>
<td>镜像 tty 的输出</td>
</tr>
<tr>
<td><code>opensnoop</code></td>
<td>系统调用</td>
<td>列出打开的文件</td>
</tr>
<tr>
<td><code>eperm</code></td>
<td>系统调用</td>
<td>统计失败的 <code>EPERM</code> 和 <code>EACCES</code> 系统调用</td>
</tr>
<tr>
<td><code>tcpconnect</code></td>
<td>TCP</td>
<td>跟踪外发 TCP 连接（主动）</td>
</tr>
<tr>
<td><code>tcpaccept</code></td>
<td>TCP</td>
<td>跟踪入站 TCP 连接（被动）</td>
</tr>
<tr>
<td><code>tcpreset</code></td>
<td>TCP</td>
<td>显示 TCP 发送重置，监测端口扫描</td>
</tr>
<tr>
<td><code>capable</code></td>
<td>安全</td>
<td>跟踪内核安全权限检查</td>
</tr>
<tr>
<td><code>setuids</code></td>
<td>系统调用</td>
<td>跟踪 <code>setuid</code> 系统调用（特权升级）</td>
</tr>
</tbody></table>
<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>对编程语言级别的监测一般可以在编写应用程序代码时确定，在运行时收集数据。但是这种方式灵活性差，不能在程序运行时修改监测逻辑，但好处是监测过程由业务逻辑和开发者意愿决定，因此这部分不在本文的范围内。</p>
<p>一共有三种不同原理的编程语言：</p>
<ul>
<li>编译型语言（如 C、C++、Golang、Rust、Pascal、Fortran 和 COBOL 等）：代码会被编译为机器码，并且保存在二进制可执行文件中。</li>
<li>即时编译型语言（如 Java、JavaScript、Julia、.Net 和 Smalltalk 等）：代码编译为字节码，在运行时阶段再编译为机器码。</li>
<li>解释型语言（如 Bash 脚本、Perl、Python 和 Ruby 等）：不会将程序函数编译为机器码，而是使用自身内置的子函数进行语法分析和执行。</li>
</ul>
<h4 id="编程语言分析策略"><a href="#编程语言分析策略" class="headerlink" title="编程语言分析策略"></a>编程语言分析策略</h4><ol>
<li>确定语言是如何执行的。应用是被编译为二进制文件、还是在运行时即时编译、还是解释执行，或者以一种混合的方式执行。</li>
<li>浏览本章提供的工具和单行程序，理解对于每种语言类型可以做的事情。</li>
<li>在互联网上搜索是否存在已知的工具，并查找如何使用 BPF 对语言进行分析。</li>
<li>检查该语言是否有 USDT 探针（在 CPU 的章节中提到过），确定它们是否在发行的二进制版本中被启用（或者重新编译以启用它们）。USDT 是稳定的插桩位置。</li>
<li>写一个样例程序来进行插桩。调用一个有确定名字和确定延迟（例如使用 <code>sleep</code> 生成延迟）的函数，这样就可以通过检查这些工具是否能够识别这些已知的量，来检查它们是否能正常工作。</li>
<li>对于用户态的软件，可以使用 uprobe 来对语言的执行过程进行监控。对于内核态软件则使用 kprobe。</li>
</ol>
<h4 id="编程语言分析相关-BPF-工具"><a href="#编程语言分析相关-BPF-工具" class="headerlink" title="编程语言分析相关 BPF 工具"></a>编程语言分析相关 BPF 工具</h4><p>对于 C 语言（编译型语言）：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>funccount</code></td>
<td>函数级别</td>
<td>统计函数调用</td>
</tr>
<tr>
<td><code>stackcount</code></td>
<td>调用栈级别</td>
<td>统计本机事件的调用栈</td>
</tr>
<tr>
<td><code>trace</code></td>
<td>函数级别</td>
<td>打印函数调用和返回值，及详细信息</td>
</tr>
<tr>
<td><code>argdist</code></td>
<td>函数级别</td>
<td>统计函数参数或返回值</td>
</tr>
<tr>
<td><code>bpftrace</code></td>
<td>所有</td>
<td>在任何调用栈插桩自定义的监测函数</td>
</tr>
</tbody></table>
<p>监控 C++ 的方式和监控 C 几乎一样，但需要考虑一些不同点：</p>
<ul>
<li>符号改变，比如 <code>ClassLoader::initialize()</code> 会编译为 <code>ZN11ClassLoader10initializeEv</code>。</li>
<li>为了支持对象和 <code>self</code> 对象，某些函数参数可能不会遵守处理器 ABI。</li>
</ul>
<p>对于 Java 语言（即时编译型语言）：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>jnistacks</code></td>
<td>libjvm</td>
<td>通过监测对象调用栈（object stack）显示 JNI 调用者</td>
</tr>
<tr>
<td><code>profile</code></td>
<td>CPU</td>
<td>基于时间的调用栈监测，包括 Java 方法函数</td>
</tr>
<tr>
<td><code>offcputime</code></td>
<td>调度</td>
<td>统计 off-CPU 时间及其调用栈信息，包括 Java 方法函数</td>
</tr>
<tr>
<td><code>stackcount</code></td>
<td>事件</td>
<td>显示给定事件的调用栈</td>
</tr>
<tr>
<td><code>javastat</code></td>
<td>USDT</td>
<td>高级语言操作统计</td>
</tr>
<tr>
<td><code>javathreads</code></td>
<td>USDT</td>
<td>跟踪线程启动和停止事件</td>
</tr>
<tr>
<td><code>javacalls</code></td>
<td>USDT</td>
<td>统计 Java 方法调用</td>
</tr>
<tr>
<td><code>javaflow</code></td>
<td>USDT</td>
<td>显示 Java 方法代码流程</td>
</tr>
<tr>
<td><code>javagc</code></td>
<td>USDT</td>
<td>跟踪 Java 垃圾回收</td>
</tr>
<tr>
<td><code>javaobjnew</code></td>
<td>USDT</td>
<td>统计 Java 新对象分配</td>
</tr>
</tbody></table>
<p>对于 Bash 脚本（解释型语言）：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>bashfunc</code></td>
<td>bash</td>
<td>监控 bash 函数调用</td>
</tr>
<tr>
<td><code>bashfunclat</code></td>
<td>bash</td>
<td>监控 bash 函数调用的耗时</td>
</tr>
</tbody></table>
<p>另外，对于 Go 语言，由于它也是编译型语言，所以监控方式也和 C 语言类似，但是在函数调用规范、协程和动态的栈管理方面有一些重要的区别。但可以通过其他方式在对 Go 程序进行调试和跟踪，包括 gdb 的 Go 运行时支持、<a target="_blank" rel="noopener" href="https://pkg.go.dev/runtime/trace">Go 运行时跟踪器</a>，以及使用 <code>gctrace</code> 和 <code>schedtrace</code> 并启用 <code>GODEBUG</code>。此外，也可以监控函数执行测试、函数入口参数函数返回值等。目前，也有面向 Go 语言的 USDT 探针工具 <a target="_blank" rel="noopener" href="https://github.com/mmcshane/salp">Salp</a>。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="应用分析策略"><a href="#应用分析策略" class="headerlink" title="应用分析策略"></a>应用分析策略</h4><ol>
<li>确定应用程序的工作单元；确定改进性能意味着什么，是更高的吞吐量、更低的延迟，或者更低的资源使用率</li>
<li>确定应用组件的相关信息。例如，使用的程序库、使用的缓存等。同时查找应用程序 API 文档，以及描述应用程序请求处理过程的信息（比如线程池模型、事件处理器模型或其他模型）。</li>
<li>确定是否有影响性能的后台计划任务（比如每 30 秒运行一次的磁盘写入事件）。</li>
<li>检查 USDT 探针是否支持该应用程序和它所使用的编程语言。</li>
<li>执行 on-CPU 分析来理解 CPU 消耗情况，并确定导致低效的位置（使用 BCC 工具 <code>profile(8)</code>）。</li>
<li>执行 off-CPU 分析来理解为什么应用程序阻塞。关注应用程序处理请求时的阻塞时间，并定位可以优化的领域（使用 BCC 工具 <code>offcputime(8)</code>、<code>wakeuptime(8)</code>、<code>offwaketime(8)</code>）。</li>
<li>分析系统调用，理解一个应用程序的资源使用情况（使用 BCC 工具 <code>syscount(8)</code>）。</li>
<li>使用 uprobe 探索应用程序的内部运行机制。比如 on-CPU 和 off-CPU 调用栈分析可以定位到很多方法，这些方法可以作为跟踪的起点。</li>
<li>对分布式计算来说，要考虑对服务器端和客户端同时进行跟踪。比如在跟踪 MySQL 请求时，需要同时追踪客户端和服务器端。</li>
</ol>
<h4 id="应用分析相关-BPF-工具"><a href="#应用分析相关-BPF-工具" class="headerlink" title="应用分析相关 BPF 工具"></a>应用分析相关 BPF 工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>execsnoop</code></td>
<td>调度</td>
<td>列出新进程的执行情况</td>
</tr>
<tr>
<td><code>threadsnoop</code></td>
<td>pthread</td>
<td>列出新线程的创建情况</td>
</tr>
<tr>
<td><code>profile</code></td>
<td>CPUs</td>
<td>on-CPU 的调用栈采样</td>
</tr>
<tr>
<td><code>threaded</code></td>
<td>CPUs</td>
<td>on-CPU 的线程采样</td>
</tr>
<tr>
<td><code>offcputime</code></td>
<td>调度</td>
<td>统计 off-CPU 时间及其调用栈</td>
</tr>
<tr>
<td><code>offcpuhist</code></td>
<td>调度</td>
<td>统计 off-CPU 时间的调用栈和时间直方图</td>
</tr>
<tr>
<td><code>syscount</code></td>
<td>系统调用</td>
<td>按类型统计系统调用</td>
</tr>
<tr>
<td><code>ioprofile</code></td>
<td>I&#x2F;O</td>
<td>统计 I&#x2F;O 上的调用栈</td>
</tr>
<tr>
<td><code>mysqld_qslower</code></td>
<td>MySQL 服务器</td>
<td>显示慢于某个阈值的 MySQL 查询</td>
</tr>
<tr>
<td><code>mysqld_clat</code></td>
<td>MySQL 服务器</td>
<td>统计 MySQL 命令延迟的直方图</td>
</tr>
<tr>
<td><code>signals</code></td>
<td>信号</td>
<td>按目标进程统计发送的信号</td>
</tr>
<tr>
<td><code>killsnoop</code></td>
<td>系统调用</td>
<td>显示 <code>kill(2)</code> 系统调用发送者的详细信息</td>
</tr>
<tr>
<td><code>pmlock</code></td>
<td>锁</td>
<td>统计 pthread 互斥锁的锁定时间和用户函数调用栈</td>
</tr>
<tr>
<td><code>pmheld</code></td>
<td>锁</td>
<td>统计 pthread 互斥锁的持有时间和用户函数调用栈</td>
</tr>
<tr>
<td><code>naptime</code></td>
<td>系统调用</td>
<td>显示自愿休眠调用</td>
</tr>
<tr>
<td><code>deadlock</code></td>
<td>锁</td>
<td>寻找潜在的死锁</td>
</tr>
</tbody></table>
<h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><h4 id="内核分析策略"><a href="#内核分析策略" class="headerlink" title="内核分析策略"></a>内核分析策略</h4><ol>
<li>创建可以触发相关事件的工作负载，知道确定的触发次数。</li>
<li>检查现有对该事件插桩的跟踪点或者工具。</li>
<li>如果该事件会被频繁调用，占用较多的 CPU 资源（&gt;5%），那么 CPU 剖析可以快速查看涉及的内核函数。如果不是频繁调用的事件，长时间的剖析可以捕捉足够多的样本（使用 <code>perf(1)</code> 或者 BCC <code>profile(8)</code>，配合 CPU 火焰图使用）。CPU 剖析还会展示自旋锁的使用，以及乐观自旋期间的互斥锁。</li>
<li>另一个探寻相关内核函数的方法是，对可能会匹配事件的函数进行计数。例如正在分析 ext4 文件系统的事件，可以尝试统计所有匹配 <code>ext4_*</code> 的函数（使用 BCC 工具 <code>funccount(8)</code>）。</li>
<li>对来自内核函数的调用栈计数，以了解代码路径（使用 BCC 工具 <code>stackcount(8)</code>）。如果进行了 CPU 剖析，那么这些代码路径应该与之相符。</li>
<li>通过子事件跟踪函数调用流（使用 perf-tools 中基于 Ftrace 的 <code>funcgraph(8)</code>）。</li>
<li>检查函数参数（使用 BCC 工具 <code>trace(8)</code> 和 <code>argdist(8)</code>，或者 <code>bpftrace</code>）。</li>
<li>测量函数延迟（使用 BCC 工具 <code>funclatency(8)</code> 或者 <code>bpftrace</code>）。</li>
<li>编写一个自定义工具对事件插桩，并打印或总结它们。</li>
</ol>
<h4 id="内核分析相关传统工具"><a href="#内核分析相关传统工具" class="headerlink" title="内核分析相关传统工具"></a>内核分析相关传统工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Ftrace</code></td>
<td>性能跟踪</td>
<td>Linux 内置跟踪器</td>
</tr>
<tr>
<td><code>perf sched</code></td>
<td>性能跟踪</td>
<td>Linux 官方性能分析器：调度器分析子命令</td>
</tr>
<tr>
<td><code>slabtop</code></td>
<td>内核统计</td>
<td>内核 <code>slab</code> 缓存使用情况</td>
</tr>
</tbody></table>
<h4 id="内核分析相关-BPF-工具"><a href="#内核分析相关-BPF-工具" class="headerlink" title="内核分析相关 BPF 工具"></a>内核分析相关 BPF 工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>loads</code></td>
<td>CPU</td>
<td>显示平均负载</td>
</tr>
<tr>
<td><code>offcputime</code></td>
<td>调度</td>
<td>统计 off-CPU 调用栈和时间</td>
</tr>
<tr>
<td><code>wakeuptime</code></td>
<td>调度</td>
<td>统计唤醒者的调用栈和阻塞时间</td>
</tr>
<tr>
<td><code>offwaketime</code></td>
<td>调度</td>
<td>统计唤醒者的 off-CPU 调用栈</td>
</tr>
<tr>
<td><code>mlock</code></td>
<td>互斥锁</td>
<td>统计互斥锁锁定时间及其内核调用栈</td>
</tr>
<tr>
<td><code>mheld</code></td>
<td>互斥锁</td>
<td>统计互斥锁持有时间及其内核调用栈</td>
</tr>
<tr>
<td><code>kmem</code></td>
<td>内存</td>
<td>统计内核内存分配</td>
</tr>
<tr>
<td><code>kpages</code></td>
<td>内存页</td>
<td>统计内核页面分配</td>
</tr>
<tr>
<td><code>memleak</code></td>
<td>内存</td>
<td>统计可能的内存泄漏代码路径</td>
</tr>
<tr>
<td><code>slabratetop</code></td>
<td>Slab</td>
<td>按缓存统计内核 <code>slab</code> 分配速率</td>
</tr>
<tr>
<td><code>numamove</code></td>
<td>NUMA</td>
<td>显示 NUMA 页面迁移统计</td>
</tr>
<tr>
<td><code>workq</code></td>
<td>工作队列</td>
<td>统计工作队列函数执行时间</td>
</tr>
</tbody></table>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>这里谈到的容器指的是通过 Linux 命名空间进行隔离、通过 cgroups 进行资源控制的虚拟化技术。在这个场景下，所有容器共享宿主机内核、共享宿主机的资源。此外也有硬件级别的虚拟化容器，可以为每个容器虚拟出一个内核，例如 <a target="_blank" rel="noopener" href="https://katacontainers.io/">Kata Containers</a>、<a target="_blank" rel="noopener" href="https://github.com/firecracker-microvm/firecracker">Firecracker</a>。</p>
<h4 id="容器分析策略"><a href="#容器分析策略" class="headerlink" title="容器分析策略"></a>容器分析策略</h4><ol>
<li>检查系统是否存在硬件资源瓶颈以及前文介绍过的 CPU、内存等问题。尤其要为正在运行的应用程序创建 CPU 火焰图。</li>
<li>检查是否遇到了 cgroups 软限制。</li>
<li>浏览和运行上文列举过的全部 BPF 工具。</li>
</ol>
<h4 id="容器分析相关传统工具"><a href="#容器分析相关传统工具" class="headerlink" title="容器分析相关传统工具"></a>容器分析相关传统工具</h4><p>从宿主机上分析：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>systemd-cgtop</code></td>
<td>内核统计</td>
<td>用于 cgroups 的 top 工具</td>
</tr>
<tr>
<td><code>kubectl top</code></td>
<td>内核统计</td>
<td>用于 Kubernetes 资源的 top 工具</td>
</tr>
<tr>
<td><code>docker stats</code> 或 <code>crictl stats</code></td>
<td>内核统计</td>
<td>容器的资源使用情况</td>
</tr>
<tr>
<td><code>/sys/fs/cgroups</code> 文件系统</td>
<td>内核统计</td>
<td>原始 cgroups 统计数据</td>
</tr>
<tr>
<td><code>perf</code></td>
<td>性能分析和统计</td>
<td>支持 cgroups 过滤器的多功能跟踪工具</td>
</tr>
</tbody></table>
<p>从容器内分析：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td>注意：进程列表是<strong>容器内的</strong>进程信息，而上方的资源摘要是<strong>主机的</strong>对应资源状态</td>
</tr>
<tr>
<td><code>ps</code></td>
<td>显示容器进程</td>
</tr>
<tr>
<td><code>uptime</code></td>
<td>显示主机统计信息，包括主机负载平均值</td>
</tr>
<tr>
<td><code>mpstat</code></td>
<td>显示主机 CPU 和主机 CPU 使用情况</td>
</tr>
<tr>
<td><code>vmstat</code></td>
<td>显示主机 CPU、内存和其他统计信息</td>
</tr>
<tr>
<td><code>iostat</code></td>
<td>显示主机磁盘信息</td>
</tr>
<tr>
<td><code>free</code></td>
<td>显示主机内存信息</td>
</tr>
</tbody></table>
<h4 id="容器分析相关-BPF-工具"><a href="#容器分析相关-BPF-工具" class="headerlink" title="容器分析相关 BPF 工具"></a>容器分析相关 BPF 工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>runqlat</code></td>
<td>调度</td>
<td>按 PID 命名空间统计 CPU 运行队列延迟</td>
</tr>
<tr>
<td><code>pidnss</code></td>
<td>调度</td>
<td>统计 PID 命名空间切换（面向共享 CPU 的容器）</td>
</tr>
<tr>
<td><code>blkthrot</code></td>
<td>块 I&#x2F;O</td>
<td>统计被 blk cgroup 限制的块 I&#x2F;O</td>
</tr>
<tr>
<td><code>overlayfs</code></td>
<td>Overlay 文件系统</td>
<td>显示 Overlay 文件系统的读写延迟</td>
</tr>
</tbody></table>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h4 id="虚拟机分析策略"><a href="#虚拟机分析策略" class="headerlink" title="虚拟机分析策略"></a>虚拟机分析策略</h4><p>对于访客系统（guest）：</p>
<ol>
<li>插桩监测<a target="_blank" rel="noopener" href="https://wiki.xenproject.org/wiki/Hypercall">超级调用</a>以检查是否有过多操作。</li>
<li>检查 CPU 被盗用的时长。</li>
<li>使用前文涉及的工具进行资源分析。需要注意的是，这些是虚拟资源，它们的性能可能会受到虚拟机管理器或硬件的资源限制，并且也可能受其他访客系统资源竞争的影响。</li>
</ol>
<p>对于宿主机系统（host）：</p>
<ul>
<li>插桩监测虚拟机的退出行为（VM-EXIT）以检查是否有过多操作。</li>
<li>如果使用了 I&#x2F;O 代理（QEMU），插桩该代理的工作负载和延迟。</li>
<li>使用前文介绍的工具进行资源分析。</li>
</ul>
<h4 id="虚拟机分析相关传统工具"><a href="#虚拟机分析相关传统工具" class="headerlink" title="虚拟机分析相关传统工具"></a>虚拟机分析相关传统工具</h4><p>对于 KVM，<code>perf(1)</code> 有一个子命令可以查看事件分析报告：<code>perf kvm stat live</code>。</p>
<h4 id="虚拟机分析相关-BPF-工具"><a href="#虚拟机分析相关-BPF-工具" class="headerlink" title="虚拟机分析相关 BPF 工具"></a>虚拟机分析相关 BPF 工具</h4><p>如果访客系统使用半虚拟化，并使用超级调用，它们就可以使用现存的工具插桩：<code>funccount(8)</code>、<code>trace(8)</code>、<code>argdist(8)</code> 和 <code>stackcount(8)</code>。</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>目标</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>xenhyper</code></td>
<td>访客系统</td>
<td>计算并显示 Xen 访客系统中的超级调用次数</td>
</tr>
<tr>
<td><code>cpustolen</code></td>
<td>访客系统</td>
<td>统计被窃取的 CPU 时间的分布</td>
</tr>
<tr>
<td><code>kvmexits</code></td>
<td>宿主机</td>
<td>统计访客系统不同原因的退出时间分布</td>
</tr>
</tbody></table>
<h2 id="技巧与建议"><a href="#技巧与建议" class="headerlink" title="技巧与建议"></a>技巧与建议</h2><h3 id="事件频率"><a href="#事件频率" class="headerlink" title="事件频率"></a>事件频率</h3><p>下面是系统中的一些常见操作及其典型的触发频率。表项『缩放的频率』是将系统事件频率类比成个人日常生活中接受邮件的频率，用来直观感受事件发生的频繁程度。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>典型频率</th>
<th>缩放的频率</th>
<th>估计的跟踪开销</th>
</tr>
</thead>
<tbody><tr>
<td>线程休眠</td>
<td>每秒 1 次</td>
<td>每年一次</td>
<td>忽略不计</td>
</tr>
<tr>
<td>进程执行</td>
<td>每秒 10 次</td>
<td>每月一次</td>
<td>忽略不计</td>
</tr>
<tr>
<td>文件打开</td>
<td>每秒 10–50 次</td>
<td>每周一次</td>
<td>忽略不计</td>
</tr>
<tr>
<td>以 100 Hz 进行采样</td>
<td>每秒 100 次</td>
<td>每周两次</td>
<td>忽略不计</td>
</tr>
<tr>
<td>新建 TCP 连接</td>
<td>每秒 10–500 次</td>
<td>每天一次</td>
<td>忽略不计</td>
</tr>
<tr>
<td>磁盘 I&#x2F;O</td>
<td>每秒 10–1000 次</td>
<td>每天三次</td>
<td>忽略不计</td>
</tr>
<tr>
<td>VFS 调用</td>
<td>每秒 1000–10,000 次</td>
<td>每小时一次</td>
<td>可测量</td>
</tr>
<tr>
<td>系统调用</td>
<td>每秒 1000–50,000 次</td>
<td>每十分钟一次</td>
<td>重要</td>
</tr>
<tr>
<td>网络数据包</td>
<td>每秒 1000–100,000 次</td>
<td>每五分钟一次</td>
<td>重要</td>
</tr>
<tr>
<td>内存分配</td>
<td>每秒 10,000–1,000,000 次</td>
<td>每三十秒一次</td>
<td>昂贵</td>
</tr>
<tr>
<td>锁定事件</td>
<td>每秒 50,000–5,000,000 次</td>
<td>每五秒一次</td>
<td>昂贵</td>
</tr>
<tr>
<td>函数调用</td>
<td>每秒 100,000,000 次</td>
<td>每秒三次</td>
<td>极高</td>
</tr>
<tr>
<td>CPU 指令</td>
<td>每秒 1,000,000,000+ 次</td>
<td>每秒三十次</td>
<td>极高（仅存在于仿真场景中）</td>
</tr>
<tr>
<td>CPU 周期</td>
<td>每秒 3,000,000,000+ 次</td>
<td>每秒九十次</td>
<td>极高（仅存在于仿真场景中）</td>
</tr>
</tbody></table>
<h3 id="BPF-操作成本"><a href="#BPF-操作成本" class="headerlink" title="BPF 操作成本"></a>BPF 操作成本</h3><p>通过 BPF 插桩也会不可避免地给系统带来额外的资源消耗，并且不同的 BPF 操作所带来的性能损耗也各不相同。下面是通过 <code>dd(1)</code> 工具，在引入不同的插桩任务时，执行一百万次读操作的耗时，用来测试不同的 BPF 操作的时间成本。</p>
<table>
<thead>
<tr>
<th>bpftrace</th>
<th>测试目的</th>
<th>运行时间（秒）</th>
<th>每事件成本（ns）</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>对照</td>
<td>5.97243</td>
<td>-</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; 1 &#125;</code></td>
<td>Kprobe</td>
<td>6.75364</td>
<td>76</td>
</tr>
<tr>
<td><code>kr:vfs_read &#123; 1 &#125;</code></td>
<td>Kretprobe</td>
<td>8.13894</td>
<td>212</td>
</tr>
<tr>
<td><code>t:syscalls:sys_enter_read &#123; 1 &#125;</code></td>
<td>Tracepoint</td>
<td>6.95894</td>
<td>96</td>
</tr>
<tr>
<td><code>t:syscalls:sys_exit_read &#123; 1 &#125;</code></td>
<td>Tracepoint</td>
<td>6.9244</td>
<td>93</td>
</tr>
<tr>
<td><code>u:libc:__read &#123; 1 &#125;</code></td>
<td>Uprobe</td>
<td>19.1466</td>
<td>1287</td>
</tr>
<tr>
<td><code>ur:libc:__read &#123; 1 &#125;</code></td>
<td>Uretprobe</td>
<td>25.7436</td>
<td>1931</td>
</tr>
<tr>
<td><code>k:vfs_read /arg2 &gt; 0/ &#123; 1 &#125;</code></td>
<td>过滤</td>
<td>7.24849</td>
<td>124</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; @ = count() &#125;</code></td>
<td>Map</td>
<td>7.91737</td>
<td>190</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; @[pid] = count() &#125;</code></td>
<td>单个 key</td>
<td>8.09561</td>
<td>207</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; @[comm] = count() &#125;</code></td>
<td>以字符串为 key</td>
<td>8.27808</td>
<td>225</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; @[pid, comm] = count() &#125;</code></td>
<td>以两个值作为 key</td>
<td>8.3167</td>
<td>229</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; @[kstack] = count() &#125;</code></td>
<td>以内核态调用栈为 key</td>
<td>9.41422</td>
<td>336</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; @[ustack] = count() &#125;</code></td>
<td>以用户态调用栈为 key</td>
<td>12.648</td>
<td>652</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; @ = hist(arg2) &#125;</code></td>
<td>直方图</td>
<td>8.35566</td>
<td>233</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; @s[tid] = nsecs &#125;</code> <br> <code>kr:vfs_read /@s[tid]/ &#123; @ = hist(nsecs - @s[tid]); delete(@s[tid]); &#125;</code></td>
<td>计时</td>
<td>12.4816</td>
<td>636 &#x2F; 2</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; @[kstack, ustack] = hist(arg2) &#125;</code></td>
<td>多个操作</td>
<td>14.5306</td>
<td>836</td>
</tr>
<tr>
<td><code>k:vfs_read &#123; printf(&quot;%d bytes\n&quot;, arg2) &#125; &gt; out.txt</code></td>
<td>输出每个事件</td>
<td>14.6719</td>
<td>850</td>
</tr>
</tbody></table>
<p>注：测试环境是启用即时编译 BPF 的 Linux 4.15、Intel(R) Core(TM) i7-8650U CPU @ 1.90GHz CPUs。为了一致性使用 <code>taskset(1)</code> 绑定到一个 CPU 上进行测试，并取最快的 10 次运行（最小扰动原理），同时检查标准偏差的一致性。</p>
<h3 id="实操建议"><a href="#实操建议" class="headerlink" title="实操建议"></a>实操建议</h3><ol>
<li>采用非常规的频率进行采样（如 99Hz），避免采样频率和某些固有频率共振，影响测量准确性。</li>
<li>采用一个不常见且区分度较大的数字（如 17、23）来模拟工作负载，用来在监测事件频率时确定对应负载会触发哪些事件。</li>
<li>系统调用常常可以用来进行跟踪。系统调用有丰富的手册文档，甚至包括传入参数和返回值。</li>
<li>kprobe 和 uprobe 的签名不稳定，会存在维护风险。因此尽可能保持程序简单，便于维护。</li>
<li>需要注意插桩的事件是不是真正触发的事件。例如如果应用程序是静态编译的，那么对应的共享库中的函数将并不会被触发。</li>
<li>监测时的调用栈缺失可能是因为编译器进行了性能优化，没有欲流寄存器 RBP 给栈指针，导致解析失败。解决办法就是通过编译参数或 Java 启动参数修复帧指针寄存器。</li>
<li>符号缺失的问题一方面可能由于调用栈损坏，第二个原因是短时进程（符号查询未完毕就退出了），第三个原因是没有可用的符号表（对于二进制文件，一方面可以调整构建过程避免去除符号；另一方面可以从其他来源获取符号信息，比如 BTF 或 debuginfo）。</li>
<li>找不到插桩的函数。可能是由于符号缺失，也有可能是因为编译器性能优化或其他原因：函数内联、尾调用优化、静态和动态链接等。</li>
<li>注意不要产生事件回路：<code>bpftrace -e &#39;k:ext4_file_write_iter&#123; printf(...) &#125;&#39; &gt; /ext4fs/out.file</code>。</li>
<li>事件频率过高时，可能会导致 perf 缓冲区溢出，丢失事件。</li>
</ol>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本文首发于：<a href="https://tech.wuzy.cn/">tech.wuzy.cn</a>，欢迎在评论区讨论交流。</p>
<p>本文主要参考、引用、修改自 Brendan Gregg 的《<a target="_blank" rel="noopener" href="https://www.brendangregg.com/bpf-performance-tools-book.html">BPF Performance Tools</a>》。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>性能分析方法论及策略——传统方法与 BPF 方法</p><p><a href="http://tech.wuzy.cn/p/performance-analysis-methodology/">http://tech.wuzy.cn/p/performance-analysis-methodology/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>吴征阳</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023年10月21日</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023年10月22日</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/BPF/">BPF</a><a class="link-muted mr-2" rel="tag" href="/tags/performance/">performance</a><a class="link-muted mr-2" rel="tag" href="/tags/Linux/">Linux</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=64b618cf1eccb80014dab4f0&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/p/is-google-cloud-run-really-a-knative/"><span class="level-item">【译】Google Cloud Run 和 Knative 真的一样吗</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "aa2969f3859c332d115c98c31340e9af",
            repo: "tech",
            owner: "wuzy-cn",
            clientID: "37119446531098242f07",
            clientSecret: "cc28378b05283670d07af46d040f2925713ee443",
            admin: ["wuzy-cn","ESWZY"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar_256%C3%97256.jpeg" alt="My Eternal Sunshine"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">My Eternal Sunshine</p><p class="is-size-6 is-block">So awesome🧣</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ESWZY" target="_blank" rel="noopener">Like!</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ESWZY"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/wuzy/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/eswzy"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Stack Overflow" href="https://stackoverflow.com/users/12866353/武状元-woa"><i class="fab fa-stack-overflow"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Youtube" href="https://www.youtube.com/@eswzy"><i class="fab fa-youtube"></i></a></div></div></div><div class="card widget is-sticky" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#性能分析方向"><span class="level-left"><span class="level-item">1</span><span class="level-item">性能分析方向</span></span></a></li><li><a class="level is-mobile" href="#性能分析方法论"><span class="level-left"><span class="level-item">2</span><span class="level-item">性能分析方法论</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#优化目标"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">优化目标</span></span></a></li><li><a class="level is-mobile" href="#业务负载画像"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">业务负载画像</span></span></a></li><li><a class="level is-mobile" href="#下钻分析"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">下钻分析</span></span></a></li><li><a class="level is-mobile" href="#USE-方法论"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">USE 方法论</span></span></a></li><li><a class="level is-mobile" href="#检查清单法"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">检查清单法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#性能分析策略"><span class="level-left"><span class="level-item">3</span><span class="level-item">性能分析策略</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#CPU"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">CPU</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#CPU-分析策略"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">CPU 分析策略</span></span></a></li><li><a class="level is-mobile" href="#CPU-分析相关传统工具"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">CPU 分析相关传统工具</span></span></a></li><li><a class="level is-mobile" href="#CPU-分析相关-BPF-工具"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">CPU 分析相关 BPF 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内存"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内存分析策略"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">内存分析策略</span></span></a></li><li><a class="level is-mobile" href="#内存分析相关传统工具"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">内存分析相关传统工具</span></span></a></li><li><a class="level is-mobile" href="#内存分析相关-BPF-工具"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">内存分析相关 BPF 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#文件系统"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">文件系统</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#文件系统分析策略"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">文件系统分析策略</span></span></a></li><li><a class="level is-mobile" href="#文件系统相关传统工具"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">文件系统相关传统工具</span></span></a></li><li><a class="level is-mobile" href="#文件系统相关-BPF-工具"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">文件系统相关 BPF 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#磁盘-I-O"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">磁盘 I/O</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#磁盘-I-O-分析策略"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">磁盘 I/O 分析策略</span></span></a></li><li><a class="level is-mobile" href="#磁盘-I-O-分析相关传统工具"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">磁盘 I/O 分析相关传统工具</span></span></a></li><li><a class="level is-mobile" href="#磁盘-I-O-分析相关-BPF-工具"><span class="level-left"><span class="level-item">3.4.3</span><span class="level-item">磁盘 I/O 分析相关 BPF 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#网络"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">网络</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#网络分析策略"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">网络分析策略</span></span></a></li><li><a class="level is-mobile" href="#网络分析相关传统工具"><span class="level-left"><span class="level-item">3.5.2</span><span class="level-item">网络分析相关传统工具</span></span></a></li><li><a class="level is-mobile" href="#网络分析相关-BPF-工具"><span class="level-left"><span class="level-item">3.5.3</span><span class="level-item">网络分析相关 BPF 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#安全"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">安全</span></span></a></li><li><a class="level is-mobile" href="#编程语言"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">编程语言</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#编程语言分析策略"><span class="level-left"><span class="level-item">3.7.1</span><span class="level-item">编程语言分析策略</span></span></a></li><li><a class="level is-mobile" href="#编程语言分析相关-BPF-工具"><span class="level-left"><span class="level-item">3.7.2</span><span class="level-item">编程语言分析相关 BPF 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#应用"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">应用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#应用分析策略"><span class="level-left"><span class="level-item">3.8.1</span><span class="level-item">应用分析策略</span></span></a></li><li><a class="level is-mobile" href="#应用分析相关-BPF-工具"><span class="level-left"><span class="level-item">3.8.2</span><span class="level-item">应用分析相关 BPF 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内核"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">内核</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内核分析策略"><span class="level-left"><span class="level-item">3.9.1</span><span class="level-item">内核分析策略</span></span></a></li><li><a class="level is-mobile" href="#内核分析相关传统工具"><span class="level-left"><span class="level-item">3.9.2</span><span class="level-item">内核分析相关传统工具</span></span></a></li><li><a class="level is-mobile" href="#内核分析相关-BPF-工具"><span class="level-left"><span class="level-item">3.9.3</span><span class="level-item">内核分析相关 BPF 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#容器"><span class="level-left"><span class="level-item">3.10</span><span class="level-item">容器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#容器分析策略"><span class="level-left"><span class="level-item">3.10.1</span><span class="level-item">容器分析策略</span></span></a></li><li><a class="level is-mobile" href="#容器分析相关传统工具"><span class="level-left"><span class="level-item">3.10.2</span><span class="level-item">容器分析相关传统工具</span></span></a></li><li><a class="level is-mobile" href="#容器分析相关-BPF-工具"><span class="level-left"><span class="level-item">3.10.3</span><span class="level-item">容器分析相关 BPF 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#虚拟机"><span class="level-left"><span class="level-item">3.11</span><span class="level-item">虚拟机</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#虚拟机分析策略"><span class="level-left"><span class="level-item">3.11.1</span><span class="level-item">虚拟机分析策略</span></span></a></li><li><a class="level is-mobile" href="#虚拟机分析相关传统工具"><span class="level-left"><span class="level-item">3.11.2</span><span class="level-item">虚拟机分析相关传统工具</span></span></a></li><li><a class="level is-mobile" href="#虚拟机分析相关-BPF-工具"><span class="level-left"><span class="level-item">3.11.3</span><span class="level-item">虚拟机分析相关 BPF 工具</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#技巧与建议"><span class="level-left"><span class="level-item">4</span><span class="level-item">技巧与建议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#事件频率"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">事件频率</span></span></a></li><li><a class="level is-mobile" href="#BPF-操作成本"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">BPF 操作成本</span></span></a></li><li><a class="level is-mobile" href="#实操建议"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">实操建议</span></span></a></li></ul></li><li><a class="level is-mobile" href="#声明"><span class="level-left"><span class="level-item">5</span><span class="level-item">声明</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo_384%C3%9788.png" alt="Eternal Sunshine" height="28"></a><p class="is-size-7"><span>&copy; 2023 吴征阳</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023 tech.wuzy.cn  <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">辽ICP备2023007095号</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>